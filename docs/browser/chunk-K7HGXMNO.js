import{a as ue,b as Se}from"./chunk-TE3AN3AP.js";import{a as xe,b as ve,c as C,d as f}from"./chunk-UZJLA2HS.js";import"./chunk-CHPLM643.js";import{a as fe}from"./chunk-LVXEBOB6.js";import"./chunk-6VWB6ZLL.js";import{c as L,g as O}from"./chunk-4LK7YMUL.js";import{f as G}from"./chunk-4AMJ3NIP.js";import{a as P}from"./chunk-RLWJFGVZ.js";import"./chunk-I6DDZT7I.js";import{A as x,C as ge,F as _,c as y,d as E,f as m,k as he,n as de,s as me}from"./chunk-AB4CTIUZ.js";import"./chunk-2HYJESCC.js";import{a as j,b as ce,e as le}from"./chunk-VJX4SEWU.js";import"./chunk-OZ5LGYCJ.js";import"./chunk-ZPQQQXRA.js";import"./chunk-Y7PYQEF4.js";import"./chunk-IQPUKORJ.js";import"./chunk-YRE2G4RX.js";import"./chunk-F7R3VTP4.js";import"./chunk-MNU4KXU7.js";import"./chunk-AJSXTGZB.js";import{d as H,f as b}from"./chunk-E24SCC45.js";import{v as g}from"./chunk-3KFX3FFC.js";import{b as M,c as pe}from"./chunk-XI5TLVWU.js";import"./chunk-M2F4B74F.js";import"./chunk-2WNCPIJC.js";import"./chunk-7ISKCG7U.js";import"./chunk-OFGHVREP.js";import"./chunk-3HX6VT75.js";import"./chunk-25T3ULWN.js";import"./chunk-X7XJWAFC.js";import"./chunk-CYCLIMTY.js";import"./chunk-RRDM7P6F.js";import"./chunk-7X2HMUNN.js";import"./chunk-NH3JQE75.js";import"./chunk-XXOIKNT6.js";import"./chunk-DBLGLVAQ.js";import"./chunk-HVNRUZWJ.js";import"./chunk-ZGDQY5ZD.js";import"./chunk-QH2MD2O2.js";import"./chunk-6EZNY6L4.js";import"./chunk-3IK5VXZ3.js";import"./chunk-7XLHE26H.js";import"./chunk-EN6CTWVM.js";import"./chunk-LVPMJTA6.js";import"./chunk-6GGK7PRJ.js";import"./chunk-NNETCWLJ.js";import"./chunk-FW33MEBA.js";import"./chunk-RM6CXOHZ.js";import"./chunk-AOA5JMXK.js";import"./chunk-TWW3KW7Z.js";import{a as w}from"./chunk-HWN5REN7.js";import{d as J,h as te,i as D,j as K,l as re,o as ie,q as se}from"./chunk-XTES2GPX.js";import{c as oe,e as ne,o as ae}from"./chunk-2HUIJUS4.js";import"./chunk-MBJHSEMD.js";import"./chunk-2R4SNL6O.js";import"./chunk-TSNWBMBA.js";import"./chunk-YFBPRKIN.js";import"./chunk-P2YRCTWM.js";import"./chunk-OFZ6SV37.js";import"./chunk-5MNDZ6BX.js";import"./chunk-YSOJWUIW.js";import"./chunk-Q5WFUDPQ.js";import"./chunk-DPZGANVI.js";import"./chunk-T7BKG6V3.js";import"./chunk-R6VC74T7.js";import"./chunk-6WKJD7BM.js";import"./chunk-3CR7P5WT.js";import"./chunk-YRTBL7EE.js";import"./chunk-3FPO2LOS.js";import"./chunk-QNZSBADV.js";import{a as T}from"./chunk-PYQRTZNZ.js";import"./chunk-GYH7NDHH.js";import"./chunk-S3UQHW42.js";import{c as $}from"./chunk-VQHENXDQ.js";import"./chunk-VWF5VUO3.js";import"./chunk-HRP5LYWJ.js";import"./chunk-BIVFGNT6.js";import"./chunk-5PTS4JDF.js";import"./chunk-MUI46NAG.js";import"./chunk-N27U3N2T.js";import"./chunk-4R5NBZMW.js";import"./chunk-NDYVXEZ5.js";import"./chunk-CMMPCPP5.js";import{da as ee}from"./chunk-4DLSYLKE.js";import"./chunk-VPXBKZQM.js";import"./chunk-ZTKK3KB7.js";import"./chunk-GZXWFBZI.js";import"./chunk-B7IARA3F.js";import"./chunk-IZVEJCCI.js";import"./chunk-TEY6TKJV.js";import"./chunk-4M6XQSBA.js";import"./chunk-2JF6YUJG.js";import{Q as I,S as Z}from"./chunk-GGZQ5GCM.js";import{U as Y}from"./chunk-TFUPB3ZG.js";import"./chunk-ANPNMGFG.js";import{a as R}from"./chunk-BMVJCP2M.js";import"./chunk-GMC3I5VG.js";import"./chunk-WGF2T2BG.js";import"./chunk-YZP43POT.js";import"./chunk-VEDIBGHD.js";import"./chunk-3IBUFXWY.js";import"./chunk-BP73DJTS.js";import{g as X}from"./chunk-JEGVIFEP.js";var v=class{constructor(r,e){this.view=r,this.options=e,this.squaredShortLineThreshold=P.shortLineThreshold*P.shortLineThreshold}snap(r,e){return e.vertexHandle!=null?e.vertexHandle.type!=="vertex"?[]:this.snapExistingVertex(r,e):this.snapNewVertex(r,e)}edgeExceedsShortLineThreshold(r,e){return this.exceedsShortLineThreshold(m(r.leftVertex.pos,this.view,e),m(r.rightVertex.pos,this.view,e),e)}exceedsShortLineThreshold(r,e,{spatialReference:t}){return this.squaredShortLineThreshold===0||x(f(e,t,g,this.view),f(r,t,g,this.view))>this.squaredShortLineThreshold}isVertical(r,e,{spatialReference:t}){let i=ee(t);return D(r,e)*i<P.verticalLineThresholdMeters}squaredProximityThreshold(r){return r==="touch"?this._squaredTouchProximityThreshold:this._squaredMouseProximityThreshold}get _squaredMouseProximityThreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){let{distance:r,touchSensitivityMultiplier:e}=this.options,t=r*e;return t*t}};var N=class extends v{snapNewVertex(r,e){let t=e.editGeometryOperations.data.components[0],i=t.edges.length,s=[];if(i<1)return s;let{spatialReference:o}=e,a=f(r,o,g,this.view),{view:n}=this,p=t.edges[i-1],h=p;do{if(this.edgeExceedsShortLineThreshold(h,e)){let d=_(h,n,e);this._processCandidateProposal(d.left,d.right,r,a,e,s)}h=h.leftVertex.leftEdge}while(h&&h!==p);return s}snapExistingVertex(r,e){let t=[],i=e.vertexHandle,s=i.component;if(s.edges.length<2)return t;let{view:o}=this,{spatialReference:a}=e,n=f(r,a,g,o),p=i.leftEdge,h=i.rightEdge;p&&h&&this.edgeExceedsShortLineThreshold(p,e)&&this.edgeExceedsShortLineThreshold(h,e)&&this._processCandidateProposal(m(p.leftVertex.pos,o,e),m(h.rightVertex.pos,o,e),r,n,e,t);let d=s.edges[0],l=d;do{if(l!==i.leftEdge&&l!==i.rightEdge&&this.edgeExceedsShortLineThreshold(l,e)){let u=_(l,o,e);this._processCandidateProposal(u.left,u.right,r,n,e,t)}l=l.rightVertex.rightEdge}while(l&&l!==d);return t}_processCandidateProposal(r,e,t,i,s,o){let{spatialReference:a,pointer:n}=s,p=T();Te(p,r,e,t,s);let h=E(p);x(i,f(h,a,g,this.view))<this.squaredProximityThreshold(n)&&o.push(new fe({lineStart:r,lineEnd:e,targetPoint:h,isDraped:s.elevationInfo?.mode==="on-the-ground"}))}};function Te(c,r,e,t,i){we(c,r,e,t,i)||ye(c,t,r,e)}function we(c,r,e,t,{spatialReference:i}){let s=L(r,e,i,i);if(s==null)return!1;let o=L(e,t,i,i);if(o==null)return!1;let a=G(e,t,i);if(a==null)return!1;let n=Math.abs(pe.shortestSignedDiff(s,o))>Math.PI/2?M.normalize(s+Math.PI):s;return O(c,e,i,b(a,"meters"),H(n,"radians","geographic"),"geodesic"),c[2]=t[2],!0}function ye(c,r,e,t){de(r,{start:e,end:t,type:le.LINE},c),c[2]=r[2]}var z=class extends v{snapNewVertex(r,e){let t=e.editGeometryOperations.data.components[0],i=t.edges.length,s=t.vertices.length,o=[];if(i<2)return o;let{view:a}=this,n=f(r,e.spatialReference,g,a),p=m(t.vertices[s-1].pos,a,e),h=m(t.vertices[0].pos,a,e),d=t.edges[i-1],l=d;do{if(this.edgeExceedsShortLineThreshold(l,e)){let u=_(l,a,e);this._checkEdgeForParallelLines(u,p,r,n,e,o),this._checkEdgeForParallelLines(u,h,r,n,e,o)}l=l.leftVertex.leftEdge}while(l&&l!==d);return o}snapExistingVertex(r,e){let t=[],i=e.vertexHandle,s=i.component;if(s.edges.length<3)return t;let{view:o}=this,a=f(r,e.spatialReference,g,o),n=i.leftEdge,p=i.rightEdge,h=s.vertices[0],d=m(h.pos,o,e),l=s.vertices.length,u=s.vertices[l-1],A=m(u.pos,o,e),k=s.edges[0],S=k;do{if(S!==n&&S!==p&&this.edgeExceedsShortLineThreshold(S,e)){let q=_(S,o,e);n&&this._checkEdgeForParallelLines(q,m(n.leftVertex.pos,o,e),r,a,e,t),p&&this._checkEdgeForParallelLines(q,m(p.rightVertex.pos,o,e),r,a,e,t),i===h?this._checkEdgeForParallelLines(q,A,r,a,e,t):i===u&&this._checkEdgeForParallelLines(q,d,r,a,e,t)}S=S.rightVertex.rightEdge}while(S&&S!==k);return t}_checkEdgeForParallelLines(r,e,t,i,s,o){let a=r.left,n=r.right;if(j(V,e,a,n),K(V,e)<P.parallelLineThreshold)return;j(V,t,a,n,e);let{spatialReference:p,pointer:h}=s,d=E(y(V[0],V[1],t[2]));if(x(i,f(d,p,g,this.view))<this.squaredProximityThreshold(h)){if(this.isVertical(d,e,s)||this.isVertical(a,n,s)||Le(r,o))return;o.push(new ue({referenceLine:r,lineStart:e,targetPoint:d,isDraped:s.elevationInfo?.mode==="on-the-ground"}))}}};function Le(c,r){let e=c.left,t=c.right;for(let i of r)if(j(V,t,i.constraint.start,i.constraint.end,e),K(V,t)<P.parallelLineThreshold)return i.addReferenceLine(c),!0;return!1}var V=w();var U=class extends v{snapNewVertex(r,e){let t=e.editGeometryOperations.data.components[0],i=[];if(t.vertices.length<2)return i;let{view:s}=this,o=f(r,e.spatialReference,g,s),a=t.vertices.at(-1);this._checkForSnappingCandidate(C.LastVertex,i,a.leftEdge,a,a.leftEdge.leftVertex,r,o,e);let n=t.vertices[0];return this._checkForSnappingCandidate(C.FirstVertex,i,n.rightEdge,n,n.rightEdge.rightVertex,r,o,e),i}snapExistingVertex(r,e){let t=[],i=e.vertexHandle;if(i.component.vertices.length<3)return t;let{view:s}=this,o=f(r,e.spatialReference,g,s),a=i.leftEdge,n=i.rightEdge;if(a?.leftVertex.leftEdge){let p=a.leftVertex.leftEdge;this._checkForSnappingCandidate(C.ExistingEdge,t,p,p.rightVertex,p.leftVertex,r,o,e)}if(n?.rightVertex.rightEdge){let p=n.rightVertex.rightEdge;this._checkForSnappingCandidate(C.ExistingEdge,t,p,p.leftVertex,p.rightVertex,r,o,e)}return t}_checkForSnappingCandidate(r,e,t,i,s,o,a,n){if(!this.edgeExceedsShortLineThreshold(t,n))return;let p=this.view,h=m(i.pos,p,n),d=m(s.pos,p,n);_e(Ee,d,h,o,n),this._checkForSnappingCandidateAlongProjectedRay(r,e,d,h,Ee,o,a,n)}_checkForSnappingCandidateAlongProjectedRay(r,e,t,i,s,o,a,n){let{spatialReference:p,pointer:h}=n,d=J(W,o,i),l=ie(s,d)/re(s),u=te(W,i,s,l),A=E(y(u[0],u[1],o[2]));if(x(a,f(A,p,g,this.view))>this.squaredProximityThreshold(h)||this.isVertical(A,i,n)||this.isVertical(i,t,n))return;let k=ae(T(),i,s,Math.sign(l));e.push(new xe({targetPoint:A,constraint:new me(i,k),previousVertex:t,otherVertex:i,otherVertexType:ve.CENTER,selfSnappingType:r,isDraped:n.elevationInfo?.mode==="on-the-ground"}))}};function _e(c,r,e,t,i){Ae(c,r,e,t,i)||Re(c,r,e)}function Ae(c,r,e,t,{spatialReference:i}){let s=L(r,e,i,i);if(s==null)return!1;let o=L(e,t,i,i);if(o==null)return!1;let a=Math.sign(M.shortestSignedDiff(s,o))*Math.PI*.5,n=H(s+a,"radians","geographic"),p=T(),h=G(e,t,i);return h!=null&&(O(p,e,i,b(h,"meters"),n,"geodesic"),ne(c,p,e),!0)}function Re(c,r,e){let t=J(W,e,r);oe(c,t[1],-t[0],0)}var W=w(),Ee=T();var B=class extends v{snapNewVertex(r,e){let t=e.editGeometryOperations.data.components[0],i=[],s=t.vertices.length;if(e.editGeometryOperations.data.type!=="polygon"||s<2)return i;let{view:o}=this,a=t.vertices[0],n=t.vertices[s-1],p=m(a.pos,o,e),h=m(n.pos,o,e);return this._processCandidateProposal(p,h,r,e,i),i}snapExistingVertex(r,e){let t=[],i=e.vertexHandle,s=i.component;if(s.edges.length<2||e.editGeometryOperations.data.type==="polyline"&&(i.index===0||i.index===s.vertices.length-1))return t;let{view:o}=this,a=m(i.leftEdge.leftVertex.pos,o,e),n=m(i.rightEdge.rightVertex.pos,o,e);return this._processCandidateProposal(a,n,r,e,t),t}_processCandidateProposal(r,e,t,i,s){if(!this.exceedsShortLineThreshold(r,e,i))return;let o=se(Pe,r,e,.5),a=.5*D(r,e),n=ce(Pe,t,o,a),p=E(y(n[0],n[1],t[2])),{spatialReference:h,pointer:d}=i,l=f(t,h,g,this.view);if(x(l,f(p,h,g,this.view))<this.squaredProximityThreshold(d)){if(this.isVertical(r,p,i)||this.isVertical(p,e,i))return;s.push(new Se({targetPoint:p,point1:r,point2:e,isDraped:i.elevationInfo?.mode==="on-the-ground"}))}}},Pe=w();var F=class extends Z{constructor(c){super(c),this.updating=!1,this._snappers=new $,this._domain=he.SELF}initialize(){this._snappers.push(new z(this.view,this.options),new N(this.view,this.options),new U(this.view,this.options),new B(this.view,this.options))}set options(c){this._set("options",c);for(let r of this._snappers)r.options=c}fetchCandidates(c,r,e){return X(this,null,function*(){if(!(r&this._domain&&this.options.effectiveSelfEnabled))return[];let t=[];for(let i of this._snappers.items)for(let s of i.snap(c,e))t.push(s);return ge(c,t),t})}};R([I({readOnly:!0})],F.prototype,"updating",void 0),R([I({constructOnly:!0})],F.prototype,"view",void 0),R([I()],F.prototype,"options",null),F=R([Y("esri.views.interactive.snapping.SelfSnappingEngine")],F);export{F as SelfSnappingEngine};
