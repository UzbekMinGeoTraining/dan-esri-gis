import{f,l as _,m as p}from"./chunk-ATV5GTE5.js";import{a as g}from"./chunk-AY3YVZUY.js";import{b as u}from"./chunk-VTCODMOL.js";import{b as h}from"./chunk-BDF7KEUQ.js";import{c as a}from"./chunk-WGF2T2BG.js";import{a as l}from"./chunk-VEDIBGHD.js";import{g as o}from"./chunk-JEGVIFEP.js";var c=class{constructor(t,e){this._module=t,this._load=e}get(){return this._module}reload(){return o(this,null,function*(){return this._module=yield this._load(),this._module})}};var s=class{constructor(t,e,r){this._context=t,this._locations=r,this._textures=new Map,this._freeTextureUnits=new l({deallocator:null}),this._glProgram=t.programCache.acquire(e.generate("vertex"),e.generate("fragment"),r),this._glProgram.stop=()=>{throw new Error("Wrapped _glProgram used directly")},this.bindPass=e.generateBindPass(this),this.bindDraw=e.generateBindDraw(this),this._fragmentUniforms=u()?e.fragmentUniforms:null}dispose(){this._glProgram.dispose()}get glName(){return this._glProgram.glName}get hasTransformFeedbackVaryings(){return this._glProgram.hasTransformFeedbackVaryings}get compiled(){return this._glProgram.compiled}setUniform1b(t,e){this._glProgram.setUniform1i(t,e?1:0)}setUniform1i(t,e){this._glProgram.setUniform1i(t,e)}setUniform1f(t,e){this._glProgram.setUniform1f(t,e)}setUniform2fv(t,e){this._glProgram.setUniform2fv(t,e)}setUniform3fv(t,e){this._glProgram.setUniform3fv(t,e)}setUniform4fv(t,e){this._glProgram.setUniform4fv(t,e)}setUniformMatrix3fv(t,e){this._glProgram.setUniformMatrix3fv(t,e)}setUniformMatrix4fv(t,e){this._glProgram.setUniformMatrix4fv(t,e)}setUniform1fv(t,e){this._glProgram.setUniform1fv(t,e)}setUniform1iv(t,e){this._glProgram.setUniform1iv(t,e)}setUniform2iv(t,e){this._glProgram.setUniform2iv(t,e)}setUniform3iv(t,e){this._glProgram.setUniform3iv(t,e)}setUniform4iv(t,e){this._glProgram.setUniform4iv(t,e)}assertCompatibleVertexAttributeLocations(t){t.locations!==this._locations&&console.error("VertexAttributeLocations are incompatible")}stop(){this._textures.clear(),this._freeTextureUnits.clear()}bindTexture(t,e){if(e?.glName==null){let i=this._textures.get(t);return i&&(this._context.bindTexture(null,i.unit),this._freeTextureUnit(i),this._textures.delete(t)),null}let r=this._textures.get(t);return r==null?(r=this._allocTextureUnit(e),this._textures.set(t,r)):r.texture=e,this._context.useProgram(this),this.setUniform1i(t,r.unit),this._context.bindTexture(e,r.unit),r.unit}rebindTextures(){this._context.useProgram(this),this._textures.forEach((t,e)=>{this._context.bindTexture(t.texture,t.unit),this.setUniform1i(e,t.unit)}),this._fragmentUniforms?.forEach(t=>{t.type!=="sampler2D"&&t.type!=="samplerCube"||this._textures.has(t.name)||console.error(`Texture sampler ${t.name} has no bound texture`)})}_allocTextureUnit(t){return{texture:t,unit:this._freeTextureUnits.length===0?this._textures.size:this._freeTextureUnits.pop()}}_freeTextureUnit(t){this._freeTextureUnits.push(t.unit)}};var d=class{constructor(t,e,r,i,n=g){this.release=i,this.locations=n,this.primitiveType=h.TRIANGLES,this.key=e.key,this._program=new s(t.rctx,r.get().build(e),n),this._pipeline=this.initializePipeline(e),this.reload=x=>o(this,null,function*(){if(x&&(yield r.reload()),!this.key.equals(e.key))throw new Error("Configuration was changed after construction, cannot reload shader");a(this._program),this._program=new s(t.rctx,r.get().build(e),n),this._pipeline=this.initializePipeline(e)})}destroy(){this._program=a(this._program),this._pipeline=null}get program(){return this._program}get compiled(){return this.program.compiled}ensureAttributeLocations(t){this.program.assertCompatibleVertexAttributeLocations(t)}getPipeline(t,e){return this._pipeline}initializePipeline(t){return p({blending:f,colorWrite:_})}};export{c as a,d as b};
