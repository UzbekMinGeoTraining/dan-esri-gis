import{b as Y}from"./chunk-KHTVZWEX.js";import{c as Z}from"./chunk-B3W5V2XP.js";import{b as X}from"./chunk-KDLA3TQ2.js";import{a as Q}from"./chunk-3PK63SMD.js";import{a as K}from"./chunk-2DN2BYDF.js";import{b as J}from"./chunk-JLNQ6WQT.js";import{a as D}from"./chunk-25T3ULWN.js";import{a as H,g as d}from"./chunk-4OZVVJHM.js";import{F as L,l as q}from"./chunk-EPTSNNZF.js";import{d as W}from"./chunk-Y6H3NTW7.js";import{a as j}from"./chunk-7W6RATG7.js";import{l as C}from"./chunk-BDF7KEUQ.js";import{e as R}from"./chunk-PYQRTZNZ.js";import{c as k}from"./chunk-HRP5LYWJ.js";import{k as z}from"./chunk-TEY6TKJV.js";import{o as U}from"./chunk-GMC3I5VG.js";import{r as V,t as F}from"./chunk-3IBUFXWY.js";import{z as S}from"./chunk-BP73DJTS.js";import{g as h}from"./chunk-JEGVIFEP.js";var p=()=>V.getLogger("esri.views.3d.layers.graphics.objectResourceUtils");function Re(t,r){return h(this,null,function*(){let a=yield se(t,r),e=yield le(a.textureDefinitions??{},r),u=0;for(let o in e)if(e.hasOwnProperty(o)){let n=e[o];u+=n?.image?n.image.width*n.image.height*4:0}return{resource:a,textures:e,size:u+S(a)}})}function se(t,r){return h(this,null,function*(){let a=r?.streamDataRequester;if(a)return oe(t,a,r);let e=yield k(z(t,r));if(e.ok===!0)return e.value.data;U(e.error),_(e.error)})}function oe(t,r,a){return h(this,null,function*(){let e=yield k(r.request(t,"json",a));if(e.ok===!0)return e.value;U(e.error),_(e.error.details.url)})}function _(t){throw new F("",`Request for object resource failed: ${t}`)}function ie(t){let r=t.params,a=r.topology,e=!0;switch(r.vertexAttributes||(p().warn("Geometry must specify vertex attributes"),e=!1),r.topology){case"PerAttributeArray":break;case"Indexed":case null:case void 0:{let o=r.faces;if(o){if(r.vertexAttributes)for(let n in r.vertexAttributes){let i=o[n];i?.values?(i.valueType!=null&&i.valueType!=="UInt32"&&(p().warn(`Unsupported indexed geometry indices type '${i.valueType}', only UInt32 is currently supported`),e=!1),i.valuesPerElement!=null&&i.valuesPerElement!==1&&(p().warn(`Unsupported indexed geometry values per element '${i.valuesPerElement}', only 1 is currently supported`),e=!1)):(p().warn(`Indexed geometry does not specify face indices for '${n}' attribute`),e=!1)}}else p().warn("Indexed geometries must specify faces"),e=!1;break}default:p().warn(`Unsupported topology '${a}'`),e=!1}t.params.material||(p().warn("Geometry requires material"),e=!1);let u=t.params.vertexAttributes;for(let o in u)u[o].values||(p().warn("Geometries with externally defined attributes are not yet supported"),e=!1);return e}function qe(t,r){let a=new Array,e=new Array,u=new Array,o=new K,n=t.resource,i=D.parse(n.version||"1.0","wosr");pe.validate(i);let P=n.model.name,w=n.model.geometries,v=n.materialDefinitions??{},b=t.textures,A=0,y=new Map;for(let T=0;T<w.length;T++){let x=w[T];if(!ie(x))continue;let B=ce(x),M=x.params.vertexAttributes,O=[],re=s=>{if(x.params.topology==="PerAttributeArray")return null;let l=x.params.faces;for(let c in l)if(c===s)return l[c].values;return null},N=M[j.POSITION],te=N.values.length/N.valuesPerElement;for(let s in M){let l=M[s],c=l.values,E=re(s)??W(te);O.push([s,new J(c,E,l.valuesPerElement,!0)])}let f=B.texture,m=b&&b[f];if(m&&!y.has(f)){let{image:s,parameters:l}=m,c=new X(s,l);e.push(c),y.set(f,c)}let $=y.get(f),ae=$?$.id:void 0,I=B.material,g=o.get(I,f);if(g==null){let s=v[I.slice(I.lastIndexOf("/")+1)].params;s.transparency===1&&(s.transparency=0);let l=m&&m.alphaChannelUsage,c=s.transparency>0||l==="transparency"||l==="maskAndTransparency",E=m?ee(m.alphaChannelUsage):void 0,G={ambient:R(s.diffuse),diffuse:R(s.diffuse),opacity:1-(s.transparency||0),transparent:c,textureAlphaMode:E,textureAlphaCutoff:.33,textureId:ae,initTextureTransparent:!0,doubleSided:!0,cullFace:H.None,colorMixMode:s.externalColorMixMode||"tint",textureAlphaPremultiplied:m?.parameters.preMultiplyAlpha??!1};r?.materialParameters&&Object.assign(G,r.materialParameters),g=new Y(G,r),o.set(I,f,g)}u.push(g);let ne=new Z(g,O);A+=O.find(s=>s[0]===j.POSITION)?.[1]?.indices.length??0,a.push(ne)}return{engineResources:[{name:P,stageResources:{textures:e,materials:u,geometries:a},pivotOffset:n.model.pivotOffset,numberOfVertices:A,lodThreshold:null}],referenceBoundingBox:ue(a)}}function ue(t){let r=L();return t.forEach(a=>{let e=a.boundingInfo;e!=null&&(q(r,e.bbMin),q(r,e.bbMax))}),r}function le(t,r){return h(this,null,function*(){let a=new Array;for(let o in t){let n=t[o],i=n.images[0].data;if(!i){p().warn("Externally referenced texture data is not yet supported");continue}let P=n.encoding+";base64,"+i,w="/textureDefinitions/"+o,v=n.channels==="rgba"?n.alphaChannelUsage||"transparency":"none",b={noUnpackFlip:!0,wrap:{s:C.REPEAT,t:C.REPEAT},preMultiplyAlpha:ee(v)!==d.Opaque},A=r?.disableTextures?Promise.resolve(null):Q(P,r);a.push(A.then(y=>({refId:w,image:y,parameters:b,alphaChannelUsage:v})))}let e=yield Promise.all(a),u={};for(let o of e)u[o.refId]=o;return u})}function ee(t){switch(t){case"mask":return d.Mask;case"maskAndTransparency":return d.MaskBlend;case"none":return d.Opaque;default:return d.Blend}}function ce(t){let r=t.params;return{id:1,material:r.material,texture:r.texture,region:r.texture}}var pe=new D(1,2,"wosr");export{Re as a,qe as b};
